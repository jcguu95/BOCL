\chapter{Introduction}
\pagenumbering{arabic}%

\section{Background}

Several \commonlisp{} implementations are written in some
language other than \commonlisp{}, even though \commonlisp{} is an
ideal language for implementing compilers and other ingredients of a
system like a \commonlisp{} implementation.  Different such
implementations are written this way for different reasons:

\begin{itemize}
\item Some creators of \commonlisp{} implementations unfortunately
  think that it is mandatory to bootstrap a \commonlisp{}
  implementation from a lower-level language.
\item Creators of some \commonlisp{} implementations write it in a
  different language because they see an advantage for inter-operation
  with other code written in that language.  \clasp{} for instance, is
  largely written in \cplusplus{} because it is designed for
  inter-operation with code written in \cplusplus{}.  Similarly,
  \ecl{} is largely written in \clanguage{} because it is designed to
  be embedded in applications written mainly in \clanguage{}.  \clasp{}
  is written largely in \cplusplus{} also because it uses LLVM for
  code generation, and the only stable API for LLVM is the
  \cplusplus{} API.
\item Implementing \commonlisp{} in a language that is widely
  available can make the resulting system more portable.  \clisp{},
  for example, has an evaluator in the form of a bytecode interpreter
  written in \clanguage{}, making it possible to install the system on
  any operating system with a \clanguage{} compiler.  Similarly, the
  \ecl{} compiler generates \clanguage{} code for final compilation by
  the \clanguage{} compiler.
\item Some distributions of operating systems require that every
  package can be built using only the \clanguage{} tool chain, such as
  the \clanguage{} compiler, Make, shell scripts, and the \unix{}
  shell utilities.
\end{itemize}

Whether the inter-operation argument is a valid one, is debatable.
The \clanguage{} ABI is stable and fairly simple, and if LLVM code can
be generated by a \commonlisp{} program, then inter-operation can be
achieved this way.  Similarly, using something like LLVM can make the
system highly portable.

The last item is the more difficult one.  If it is desirable for the
final \commonlisp{} system to be available on distributions of
operating systems with such restrictions, then it would appear to be
necessary to implement the system in \clanguage{}.  The \sysname{}
project addresses this very issue.

\section{Issues with using other implementation languages}

When a language such as \clanguage{} is used to implement a
\commonlisp{} system, a large part of such a system is still written
in \commonlisp{}, or a subset thereof.  Typically, the other language
is used only for a minimal core, on top of which code written in
\commonlisp{} can be added in order to obtain a complete system.  And
it would be impractical to write an optimizing \commonlisp{} compiler
in a language such as \clanguage{} so the compiler of the system is
often written in \commonlisp{}.

Even though a large part of a \commonlisp{} system written in (say)
\clanguage{} is written in \commonlisp{}, this technique generates
several issues:

\begin{itemize}
\item The system has to be built in layers, starting with the minimal
  core, and each module added can use only the subset of \commonlisp{}
  defined by the previously loaded modules, whereas a system written
  entirely in \commonlisp{} can use the full \commonlisp{} language of
  the host \commonlisp{} system.  The layered approach adds to the
  maintenance burden, because the exact subset of \commonlisp{}
  allowed for each layer must be kept in mind (or must be documented)
  when a module evolves.
\item The \clanguage{} ABI is not adapted to \commonlisp{}.  In
  particular, it does not allow for general tail-call optimization.
  So a system that respects the \clanguage{} ABI for inter-operation
  may not obtain the best run-time performance because of the
  necessity to adapt to limitations of \clanguage{}.
\item Frequently, \clanguage{} is used for its low-level features,
  allowing relatively simple manipulations of pointers and memory, for
  things like garbage collection and management of tagged data.
  However, using \clanguage{} this way frequently makes the code
  not conforming to the standard for \clanguage{}.  In the worst case,
  a particular version of a particular \clanguage{} compiler must be
  used to build the final \commonlisp{} system.
\item Code written in a lower-level language is harder to maintain
  than code written in \commonlisp{}, and low-level code written for a
  particular \commonlisp{} implementation is highly specific to that
  implementation.  As a result the existence of free \commonlisp{}
  systems written this way necessarily increases the collective
  maintenance burden, which is problematic, given the limited
  resources of the \commonlisp{} community.
\end{itemize}

\section{Purpose of \sysname{}}

The purpose of this project is the creation of a conforming
\commonlisp{} system, including also widely used features such as the
Meta-Object Protocol (MOP) and perhaps some other features as well.
But \sysname{} is not meant for application programming, and should be
used only in order to bootstrap other \commonlisp{} implementations
written entirely or mostly in \commonlisp{}.  Another purpose is to
address some of the issues previously indicated, and in particular the
restriction of some operating-system distributions requiring every
package to be built using only the \clanguage{} tool chain.

To address these issues, \sysname{} has a core written in
standards-conforming \clanguage{}, just like a typical existing
\commonlisp{} system written largely in \clanguage{}.  A valid
question, then, is why a new \commonlisp{} implementation is needed,
and why some existing implementation such as \ecl{} or \clisp{} could
not serve the same purpose.  The answer is that \sysname{} also
addresses some of the other issues previously discussed:

\begin{itemize}
\item \sysname{} is written in conforming \clanguage{}, so it can be
  built using any version of any conforming \clanguage{} compiler.
\item Existing implementations are written with application
  programming in mind, requiring significant attention to run-time
  performance.  To obtain reasonable performance, existing
  implementations require more code, and more specialized code, than
  would otherwise be needed.  On the other hand, \sysname{} is written
  with maintainability in mind, perhaps making bootstrapping of a
  final \commonlisp{} implementation a bit slower than it would be
  using \ecl{} or \clisp{}.
\end{itemize}


